/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
author: Warkarma (https://sketchfab.com/warkarma)
license: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
source: https://sketchfab.com/3d-models/dungeon-low-poly-game-level-challenge-0fd0d477d7424e5d8915ce0c06a2920d
title: Dungeon - Low Poly Game Level Challenge
*/

import React, { useRef } from "react";
import { useGLTF } from "@react-three/drei";
import gltfUrl from "../src/models/plane_sculpt_copy.gltf?url";
import { useLayoutEffect } from "react";
import create from "zustand";
import { Box3, MathUtils, Vector3 } from "three";
import { LayerMaterial } from "lamina";
import { Depth } from "lamina";
import { Fresnel } from "lamina";
import { Displace } from "lamina";
import { Noise } from "lamina";
import { useFrame } from "@react-three/fiber";

useGLTF.preload(gltfUrl);

export const useStore = create((set) => ({
  nodes: [],
  snapshots: [],
  addSnapshots: (node) =>
    set((state) => ({
      ...state,
      snapshots: [...state.snapshots.slice(-100), node],
    })),
  playerRef: null,
  setPlayerRef: (playerRef) => set((state) => ({ ...state, playerRef })),
  velocity: new Vector3(),
  getDeltaVector: () => new Vector3(),
  onGround: false,
  setOnGround: (onGround) => set((state) => ({ ...state, onGround })),
  setGetDeltaVector: (fn) => set((state) => ({ ...state, getDeltaVector: fn })),
  setNodes: (nodes) => set((state) => ({ ...state, nodes })),
  addNode: (node) =>
    set((state) => ({ ...state, nodes: [...state.nodes, node] })),
}));

export default function Model({ ref, ...props }) {
  const innerRef = useRef();
  const group = ref ?? innerRef;
  const { nodes } = useGLTF(gltfUrl);
  const setNodes = useStore((state) => state.setNodes);
  const addNode = useStore((state) => state.addNode);
  useLayoutEffect(() => {
    const box = new Box3();
    box.setFromObject(group.current);
    box.getCenter(group.current.position).negate();
    group.current.updateMatrixWorld(true);

    setNodes([]);
    setTimeout(() => group.current.traverse(addNode), 1000);
  }, []);
  const strength = useRef(0.2);
  const displaceRef = useRef(null);

  useFrame((_, dt) => {
    if (!displaceRef.current) return;

    if (displaceRef.current.strength !== strength.current) {
      displaceRef.current.strength = MathUtils.lerp(
        displaceRef.current.strength, //
        strength.current,
        0.1
      );
    }

    if (strength.current > 0) {
      displaceRef.current.offset.x += 0.3 * dt;
    }
  });

  return (
    <group
      ref={group}
      {...props}
      dispose={null}
      position={[-20, 100, -20]}
      scale={[2.5, 0.4, 2.5]}
    >
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Plane_Sculpt.geometry}
        material={nodes.Plane_Sculpt.material}
        rotation={[-Math.PI / 2, 0, -Math.PI / 2]}
      >
        <meshStandardMaterial wireframe opacity={0.1} transparent />
      </mesh>
    </group>
  );
}
